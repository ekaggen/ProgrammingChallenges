/* 	Solution to Programming Challenges Problem	http://www.programming-challenges.com		Author: Eric Kaggen	Problem: Star (111203)		This solution favors readability over elegance. The	assumption is made that program input follows supplied	specifications. Handling of boundary cases outside of the	specifications is omitted. This is meant for fun rather than	practical use. Code style reflects the purpose of the code.*/#include <iostream>#include <list>#include <vector>#include <stdio.h>#include <stdlib.h>#include <time.h>using namespace std;#define NONE -1#define A 0#define B 1#define C 2#define D 3#define E 4#define F 5#define G 6#define H 7#define I 8#define J 9#define K 10#define L 11struct cell{	int memberOf[3];	int memberOfCount;	int value;	bool empty;	int index;	cell()	{		this->value = 0;		this->memberOfCount = 0;	}	cell(int value)	{		this->value = value;	}};class Backtracker{	struct InputElement	{		cell theCell;		bool inSol;		int basis[3];		InputElement(cell theCell)		{			this->theCell = theCell;			inSol = false;		}	};public:	vector<InputElement*> partialSolution;	vector<InputElement> input;	int* maxValue;	bool done;	int pairSize;	Backtracker(cell cells[48], int* maxValue, bool accountedFor[12], int pairSize)	{		this->done = false;		this->maxValue = maxValue;		this->pairSize = pairSize;		for(int i = 0; i < 48; i++)		{			cell c = cells[i];			int memberCopy[3];			int nMemberCopy = 0;			for(int j = 0; j < c.memberOfCount; j++)			{				if(!accountedFor[c.memberOf[j]])				{					memberCopy[nMemberCopy++] = c.memberOf[j];				}			}			if(nMemberCopy >= pairSize)			{				for(int j = 0; j < nMemberCopy; j++)				{					c.memberOf[j] = memberCopy[j];				}				c.memberOfCount = nMemberCopy;				input.push_back(InputElement(c));			}		}	}		void backtrack()	{			list<InputElement*> candidates;		list<InputElement*>::iterator it;		if(partialSolution.size() > bestSolution.size())		{			this->processSolution();			return;		}		constructCandidates(&candidates);		for(it = candidates.begin(); it != candidates.end(); it++)		{			partialSolution.push_back(*it);			(*it)->inSol = true;			// make move			backtrack();			partialSolution.pop_back();			(*it)->inSol = false;			if(done)				return;		}	}	vector<InputElement*> bestSolution;	void processSolution()	{		bestSolution = partialSolution;	}	void constructCandidates(list<InputElement*>* candidates)	{		for(unsigned int i = 0; i < input.size(); i++)		{			InputElement* element=  &input.at(i);			cell c  = element->theCell;			if(!element->inSol/* &&c.memberOfCount == 3*/)			{				int val = maxValue[c.memberOf[0]];				bool valid = true;				bool alreadyTaken[] = {false, false, false};				for(int j = 0; j < partialSolution.size(); j++)				{					cell psCell = partialSolution.at(j)->theCell;					for(int a = 0; a < c.memberOfCount; a++)					{						for(int b = 0; b < psCell.memberOfCount; b++)						{							if(c.memberOf[a] == psCell.memberOf[b])							{								alreadyTaken[a] = true;							}						}					}				}				if(pairSize == 3)				{					if(alreadyTaken[0] || alreadyTaken[1] || alreadyTaken[2])						continue;					for(int j = 0; j < 3; j++)					{						if(maxValue[c.memberOf[j]] != val)						{							valid = false;							break;						}					}				}				else				{					if(c.memberOfCount == 2)					{						if(maxValue[c.memberOf[0]] == maxValue[c.memberOf[1]] && !alreadyTaken[0] && !alreadyTaken[1])						{							valid = true;							element->basis[0] = true;							element->basis[1] = true;							element->basis[2] = false;						}						else						{							valid = false;						}					}					else if(maxValue[c.memberOf[0]] == maxValue[c.memberOf[1]] && maxValue[c.memberOf[0]] <= maxValue[c.memberOf[2]] && !alreadyTaken[0] && !alreadyTaken[1])					{						valid = true;						element->basis[0] = true;						element->basis[1] = true;						element->basis[2] = false;					}					else if(maxValue[c.memberOf[0]] == maxValue[c.memberOf[2]]  && maxValue[c.memberOf[0]] <= maxValue[c.memberOf[1]] && !alreadyTaken[0] && !alreadyTaken[2])					{						valid = true;						element->basis[0] = true;						element->basis[1] = false;						element->basis[2] = true;					}					else if( maxValue[c.memberOf[1]] == maxValue[c.memberOf[2]]  && maxValue[c.memberOf[1]] <= maxValue[c.memberOf[0]] && !alreadyTaken[1] && !alreadyTaken[2])					{						valid = true;						element->basis[0] = false;						element->basis[1] = true;						element->basis[2] = true;					}					else					{						valid = false;					}				}				if(valid)				{					candidates->push_back(element);				}			}		}	}};int main(){	int maxValue[12];	bool accountedFor[12];	int numCounts[10];	cell allCells[48];	vector<cell*> lines[12];	int cellMap[12][11] = {		{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10},		{11, 12, 13, 14, 15, 16, 17, 18, 19, -1, -1},		{20, 21, 22, 23, 24, 25, 26, 27, 28, -1, -1},		{29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39},		{29, 30, 20, 21, 12, 13, 3, 4, 45, 46, 44},		{31, 32, 22, 23, 14, 15, 5, 6, 47, -1, -1},		{40, 33, 34, 24, 25, 16, 17, 7, 8, -1, -1},		{43, 41, 42, 35, 36, 26, 27, 18, 19, 9, 10},		{43, 41, 40, 33, 32, 22, 21, 12, 11, 1, 0},		{42, 35, 34, 24, 23, 14, 13, 3, 2, -1, -1},		{37, 36, 26, 25, 16, 15, 5, 4, 45, -1, -1},		{39, 38, 28, 27, 18, 17, 7, 6, 47, 46, 44}	};	for(int i = 0; i < 12; i++)	{		for(int j = 0; j < 11; j++)		{			if(cellMap[i][j] == -1)				continue;			cell* curCell = &allCells[cellMap[i][j]];			lines[i].push_back(curCell);			curCell->memberOf[curCell->memberOfCount++] = i;			curCell->index = cellMap[i][j];		}	}	while ( scanf ("%d %d %d %d %d %d %d %d %d %d %d %d",		&maxValue[0],&maxValue[1],&maxValue[2],&maxValue[3],		&maxValue[4],&maxValue[5],&maxValue[6],&maxValue[7],		&maxValue[8],&maxValue[9],&maxValue[10],&maxValue[11]) != EOF )	{		bool noSolution = false;		for(int i = 0; i < 48; i++)	allCells[i].empty = true;		for(int l = 0; l < 12; l++)		{			for(int i = 0; i < lines[l].size(); i++)			{				cell* cur = lines[l].at(i);				if(cur->empty)				{					cur->value = maxValue[l];					cur->empty = false;				}				else if(cur->value > maxValue[l])				{					cur->value = maxValue[l];				}			}		}		for(int l = 0; l < 12; l++)		{			bool lineOk = false;			for(int i = 0; i < lines[l].size(); i++)			{				cell* cur = lines[l].at(i);				if(cur->value == maxValue[l])				{					lineOk = true;					break;				}			}			if(!lineOk)			{				noSolution = true;				break;			}		}		if(noSolution)		{			cout<<"NO SOLUTION"<<endl;			continue;		}		int sum = 0;		for(int i = 0; i < 48; i++)		{			sum += allCells[i].value;			for(int j = 0; j < allCells[i].memberOfCount; j++)			{				if(allCells[i].value > maxValue[allCells[i].memberOf[j]])				{					while(true);				}			}		}		int minValue = 0;		for(int i = 0; i < 10; i++)		{			numCounts[i] = 0;		}		for(int i = 0; i < 12; i++)		{			accountedFor[i] = false;			numCounts[maxValue[i]]++;		}		for(int i = 0; i < 48; i++)		{			allCells[i].empty = true;			allCells[i].value = 0;		}		Backtracker backtracker3(allCells, maxValue, accountedFor, 3);		backtracker3.backtrack();		for(int i = 0; i < backtracker3.bestSolution.size(); i++)		{			cell* theCell = &backtracker3.bestSolution.at(i)->theCell;			allCells[theCell->index].value = maxValue[theCell->memberOf[0]];			allCells[theCell->index].empty = false;			minValue += maxValue[theCell->memberOf[0]];			for(int j = 0; j < 3; j++)			{				accountedFor[theCell->memberOf[j]] = true;			}		}		Backtracker backtracker2(allCells, maxValue, accountedFor, 2);		backtracker2.backtrack();		for(int i = 0; i < backtracker2.bestSolution.size(); i++)		{			cell* theCell = &backtracker2.bestSolution.at(i)->theCell;						allCells[theCell->index].empty = false;						for(int j = 0; j < 3; j++)			{				if(backtracker2.bestSolution.at(i)->basis[j])				{					allCells[theCell->index].value = maxValue[theCell->memberOf[j]];					accountedFor[theCell->memberOf[j]] = true;				}			}			minValue += allCells[theCell->index].value;		}		for(int i = 0; i < 48; i++)		{			if(!allCells[i].empty)				continue;			for(int j = 0; j < 3; j++)			{				int first = allCells[i].memberOf[j];				int second = allCells[i].memberOf[(j+1)%3];				if(!accountedFor[first] && !accountedFor[second] && maxValue[first] == maxValue[second])				{					if(allCells[i].memberOfCount == 3)					{						int third = allCells[i].memberOf[(j+2)%3];						if(maxValue[third] < maxValue[first])						{							break;						}					}					accountedFor[first] = true;					accountedFor[second] = true;					minValue += maxValue[first];					allCells[i].value = maxValue[first];					allCells[i].empty = false;					break;				}				if(allCells[i].memberOfCount == 2)					break;			}		}		for(int l = 0; l < 12; l++)		{			if(!accountedFor[l])			{				for(int i = 0; i < lines[l].size(); i++)				{					cell* cur = lines[l].at(i);					if(cur->empty)					{						bool valid = true;						for(int j = 0; j < cur->memberOfCount; j++)						{							if(maxValue[cur->memberOf[j]] < maxValue[l])							{								valid = false;								break;							}						}						if(!valid)							continue;						cur->value = maxValue[l];						cur->empty = false;						minValue += maxValue[l];						accountedFor[l] = true;						break;					}				}							}		}		for(int l = 0; l < 12; l++)		{			if(!accountedFor[l])			{				while(true);			}			for(int i = 0; i < lines[l].size(); i++)			{				cell* cur = lines[l].at(i);				if(cur->value > maxValue[l])				{					while(true);				}			}		}		cout<<minValue<<" "<<sum<<endl;	}		return 0;}