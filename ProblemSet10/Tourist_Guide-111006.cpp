/* 	Solution to Programming Challenges Problem	http://www.programming-challenges.com		Author: Eric Kaggen	Problem: Tourist Guide (111006)		This solution favors readability over elegance. The	assumption is made that program input follows supplied	specifications. Handling of boundary cases outside of the	specifications is omitted. This is meant for fun rather than	practical use. Code style reflects the purpose of the code.*/#include <iostream>#include <vector>#include <string>#include <queue>#include <algorithm>using namespace std;struct location{	string name;	bool visited;	bool marked;	vector<location*> neighbors;	location(string name)	{		this->name = name;		visited = false;		marked = false;	}};int main(){	string buf1, buf2;	int nLocations, nRoutes;	vector<location*>::iterator it;	int caseNum = 0;	bool firstCase = true;	while(true)	{		cin>>nLocations;		if(nLocations == 0)			break;		if(!firstCase)			cout<<"\n";		firstCase = false;		caseNum++;		vector<location> locations;		for(int i = 0; i < nLocations;i++)		{			cin>>buf1;			locations.push_back(location(buf1));		}		cin>>nRoutes;		// Read pairs of locations and link them explicitly		for(int i = 0; i < nRoutes;i++)		{			cin>>buf1;			cin>>buf2;			location* first = NULL;			location* second = NULL;			for(int j = 0; j < locations.size(); j++)			{				if(locations[j].name == buf1)				{					first = &locations[j];				}				if(locations[j].name == buf2)				{					second = &locations[j];				}			}			first->neighbors.push_back(second);			second->neighbors.push_back(first);		}		for(int j = 0; j < locations.size(); j++)		{			locations[j].visited = false;		}		vector<string> cameras;		for(int i = 0; i < locations.size(); i++)		{			if(locations[i].neighbors.size() == 0)				continue;			for(int j = 0; j < locations.size(); j++)			{				locations[j].visited = false;				locations[j].marked = false;			}			// Do BFS to mark all locations which are connected to this location			queue<location*> q;			q.push(&locations[i]);			locations[i].marked = true;			while(!q.empty())			{				location* current = q.front();				q.pop();				for(int j = 0; j < current->neighbors.size(); j++)				{					if(!current->neighbors[j]->marked)					{						current->neighbors[j]->marked = true;						q.push(current->neighbors[j]);					}				}			}			// Is the graph still connected?			q.push(locations[i].neighbors[0]);			locations[i].visited = true;			while(!q.empty())			{				location* current = q.front();				current->visited = true;				q.pop();				for(int j = 0; j < current->neighbors.size(); j++)				{					if(!current->neighbors[j]->visited)					{						current->neighbors[j]->visited = true;						q.push(current->neighbors[j]);					}				}			}			// Based on the search place the cameras			for(int j = 0; j < locations.size(); j++)			{				if(!locations[j].visited && locations[j].marked)				{					cameras.push_back(locations[i].name);					break;				}			}		}				// Now print the results		cout<<"City map #"<<caseNum<<": "<<cameras.size()<<" camera(s) found"<<endl;		sort(cameras.begin(), cameras.end());		for(int i = 0; i < cameras.size(); i++)		{			cout<<cameras[i]<<endl;		}	}	return 0;}