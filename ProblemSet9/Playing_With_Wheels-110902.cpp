/* 	Solution to Programming Challenges Problem	http://www.programming-challenges.com		Author: Eric Kaggen	Problem: Playing with Wheels (110902)		This solution favors readability over elegance. The	assumption is made that program input follows supplied	specifications. Handling of boundary cases outside of the	specifications is omitted. This is meant for fun rather than	practical use. Code style reflects the purpose of the code.*/#include <iostream>#include <stdio.h>#include <queue>using namespace std;struct WheelState{	int digits[4];	bool operator==(const WheelState &other) const	{		for(int i = 0; i < 4; i++)		{			if(digits[i] != other.digits[i])			{				return false;			}		}		return true;	}};struct PathNode{	int length;	WheelState state;	PathNode() {}	PathNode(WheelState state)	{		this->state = state;		this->length = 0;	}};int main(){	int nForbiddenStates;	int cases;	int pathLength;	char line[5];	// Keep track of visited states in the implicit graph	bool visited[10][10][10][10];	WheelState initialState;	WheelState finalState;	PathNode current;	cin>>cases;	cin.getline(line, 5);	cin.getline(line, 5);	while(cases-- > 0)	{		int pathLen = 0;		// Zero out the visited array		for(int a = 0; a < 10; a++)			for(int b = 0; b < 10; b++)				for(int c = 0; c < 10; c++)					for(int d = 0; d < 10; d++)						visited[a][b][c][d] = false;		for(int i = 0; i < 4; i++)		{			cin>>initialState.digits[i];		}				for(int i = 0; i < 4; i++)		{			cin>>finalState.digits[i];		}		cin>>nForbiddenStates;		// Set all forbidden states to visited so they're ignored		for(int f = 0; f < nForbiddenStates; f++)		{			WheelState forbiddenState;			for(int i = 0; i < 4; i++)			{				cin>>forbiddenState.digits[i];						}			visited[forbiddenState.digits[0]][forbiddenState.digits[1]][forbiddenState.digits[2]][forbiddenState.digits[3]] = true;		}				// Now do implicit breadth first search		queue<PathNode> q;		q.push(PathNode(initialState));		bool success = false;		while(!q.empty())		{			// First the head of the queue			current = q.front();			visited[current.state.digits[0]][current.state.digits[1]][current.state.digits[2]][current.state.digits[3]] = true;						// We found it			if(current.state == finalState)			{				success = true;				break;			}			q.pop();						// Now compute neighbors (there could be 8 total)			for(int i = 0; i < 4; i++)			{				PathNode plusNode = current;				PathNode minusNode = current;				plusNode.state.digits[i] = (plusNode.state.digits[i] + 1) % 10; // Increase wheel				minusNode.state.digits[i] = (minusNode.state.digits[i] + 9) % 10; // Decrease wheel				// Path is 1 node longer now				plusNode.length++;				minusNode.length++;				// Queue up the unvisited of the plusNode/minusNode				if(!visited[plusNode.state.digits[0]][plusNode.state.digits[1]][plusNode.state.digits[2]][plusNode.state.digits[3]])				{					q.push(plusNode);					visited[plusNode.state.digits[0]][plusNode.state.digits[1]][plusNode.state.digits[2]][plusNode.state.digits[3]] = true;				}				if(!visited[minusNode.state.digits[0]][minusNode.state.digits[1]][minusNode.state.digits[2]][minusNode.state.digits[3]])				{					visited[minusNode.state.digits[0]][minusNode.state.digits[1]][minusNode.state.digits[2]][minusNode.state.digits[3]] = true;					q.push(minusNode);				}			}		}		if(success)		{			cout<<current.length<<endl;		}		else		{			cout<<"-1"<<endl;		}	}	return 0;}