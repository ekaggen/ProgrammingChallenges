/* 	Solution to Programming Challenges Problem	http://www.programming-challenges.com		Author: Eric Kaggen	Problem: Garden of Eden (110806)		This solution favors readability over elegance. The	assumption is made that program input follows supplied	specifications. Handling of boundary cases outside of the	specifications is omitted. This is meant for fun rather than	practical use. Code style reflects the purpose of the code.*/#include <iostream>#include <stdio.h>#include <vector>#include <list>using namespace std;class Backtracker{public:	vector<bool> partialSolution;	unsigned int type;	vector<bool> testState;	bool done;	bool success;	Backtracker(unsigned int type, vector<bool> testState)	{		this->testState = testState;		this->type = type;		this->success = false;		this->done = false;	}		void backtrack()	{			vector<bool> candidates;		if(isSolution())		{			this->processSolution();			return;		}		constructCandidates(&candidates);		for(int i = 0; i < candidates.size(); i++)		{			partialSolution.push_back(candidates.at(i));			// make move			backtrack();			partialSolution.pop_back();			if(done)				return;		}	}	bool isSolution()	{		if(partialSolution.size() == testState.size())		{				int shift = (((int)partialSolution.back() << 2) | ((int)partialSolution.front() << 1) | (int)partialSolution[1]);				bool newState = (type >> shift) & 1 == 1;				if(testState[0] == newState)				{					shift = (((int)partialSolution[0] << 2) | ((int)partialSolution[1] << 1) | (int)partialSolution[2]);					newState = (type >> shift) & 1 == 1;					if(testState[1] == newState)					{						return true;					}					else					{						return false;					}				}				else				{					return false;				}		}		return false;	}	void processSolution()	{		done = true;		success = true;	}	void constructCandidates(vector<bool>* candidates)	{		if(partialSolution.size() == testState.size())			return;		if(partialSolution.size() < 2)		{			candidates->push_back(true);			candidates->push_back(false);		}		else if(partialSolution.size() == testState.size() - 1) // Nearly done, need to wrap to first element		{			bool left = partialSolution[partialSolution.size() - 2];			bool center = partialSolution[partialSolution.size() - 1];			// Two possible transitions depending on what the value of the right cell is			int shift = (((int)left << 2) | ((int)center << 1));			bool transition1 = (type >> shift) & 1 == 1;			bool transition2 = (type >> shift+1) & 1 == 1;			bool target = testState[partialSolution.size() - 1];			bool falseCand = target == transition1;			bool trueCand = target == transition2;			left = partialSolution[partialSolution.size() - 1];			bool right = partialSolution[0];			shift = (((int)left << 2) | ((int)right));			transition1 = (type >> shift) & 1 == 1;			transition2 = (type >> shift+2) & 1 == 1;			target = testState.back();			if(target == transition1 && falseCand)			{				candidates->push_back(false);			}			if(target == transition2 && trueCand)			{				candidates->push_back(true);			}		}		else		{			bool left = partialSolution[partialSolution.size() - 2];			bool center = partialSolution[partialSolution.size() - 1];			// Two possible transitions depending on what the value of the right cell is			int shift = (((int)left << 2) | ((int)center << 1));			bool transition1 = (type >> shift) & 1 == 1;			bool transition2 = (type >> shift+1) & 1 == 1;			bool target = testState[partialSolution.size() - 1];			if(target == transition1)			{				candidates->push_back(false);			}			if(target == transition2)			{				candidates->push_back(true);			}		}	}};int main(){	unsigned int type;	int testLen;	char testStateStr[33];	bool left = false;	bool cur = false;		while ( scanf ("%d %d %s", &type, &testLen, testStateStr) != EOF )	{		vector<bool> testState;		for(int i = 0; i < testLen; i++)		{			testState.push_back(testStateStr[i] == '1');		}		Backtracker bt(type, testState);		bt.backtrack();				// Did backtracking find a solution?		if(bt.success)			cout<<"REACHABLE"<<endl;		else			cout<<"GARDEN OF EDEN"<<endl;	}    return 0;}