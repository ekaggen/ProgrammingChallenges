/* 	Solution to Programming Challenges Problem	http://www.programming-challenges.com		Author: Eric Kaggen	Problem: Weights and Measures (111103)		This solution favors readability over elegance. The	assumption is made that program input follows supplied	specifications. Handling of boundary cases outside of the	specifications is omitted. This is meant for fun rather than	practical use. Code style reflects the purpose of the code.*/#include <stdio.h>#include <iostream>#include <algorithm>#include <vector>using namespace std;struct turtle{	int weight;	int strength;	turtle(int w, int s)	{		this->weight = w;		this->strength = s;	}};// Sorting our turtles by strength, weightbool compareTurtles(turtle a, turtle b){	if(a.strength == b.strength)	{		return a.weight > b.weight;	}	return a.strength<b.strength;}int turtleStack[5700][5700];int main(){	int weight, strength;	int inf = 1<<30;	vector<turtle> turtles;		int ident = 0;	while ( scanf ("%d %d", &weight, &strength) != EOF )	{		if(strength < weight)			continue;		turtles.push_back(turtle(weight, strength));	}	sort(turtles.begin(), turtles.end(), compareTurtles);		for(int i = 0; i < turtles.size(); i++)	{		for(int j = 0; j < turtles.size(); j++)		{			turtleStack[i][j] = inf;		}	}	// Add weakest turtle to stack	for(int i = 0; i < turtles.size(); i++)		turtleStack[i][0] = turtles[0].weight;	// One round per turtle	int maxPos = 0;	for(int round = 1; round < turtles.size(); round++)	{		// Leaving top of stack alone		for(int pos = 1; pos <= round; pos++)		{			// Copy value of previous round in this position			turtleStack[round][pos] = turtleStack[round - 1][pos];			// Is this turtle strong enough to hold up stack from previous round, and his own?			int totalWeight = turtleStack[round - 1][pos - 1] + turtles[round].weight;			if(totalWeight <= turtles[round].strength)			{				if(totalWeight < turtleStack[round][pos])				{					turtleStack[round][pos] = totalWeight;					maxPos = max(maxPos, pos);				}			}					}	}	cout<<maxPos+1<<endl;	return 0;}