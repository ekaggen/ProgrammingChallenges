/* 	Solution to Programming Challenges Problem	http://www.programming-challenges.com		Author: Eric Kaggen	Problem: Unidirectional TSP (111104)		This solution favors readability over elegance. The	assumption is made that program input follows supplied	specifications. Handling of boundary cases outside of the	specifications is omitted. This is meant for fun rather than	practical use. Code style reflects the purpose of the code.*/#include <stdio.h>#include <iostream>#include <vector>using namespace std;int main(){	int m, n;	while ( scanf ("%d %d", &m,&n) != EOF )	{		vector<vector<long long> > matrix;		vector<vector<long long> > cost;		vector<int> pathStarts;		vector<vector<int> > paths;				// Build the base matrix from input		for(int i = 0; i < m; i++)		{			vector<long long> row;			matrix.push_back(row);			for(int j = 0; j < n; j++)			{				int val;				cin>>val;				matrix[i].push_back(val);			}					}		cost = matrix; // Copy matrix over as costs				// Scan over from the top right and calculate costs using DP		for(int j = n-2; j >= 0; j--)		{			for(int i = 0; i < m; i++)			{				cost[i][j] += min(cost[i][j+1], min(cost[(i + m - 1) % m][j+1], cost[(i + m + 1) % m][j+1]));			}		}				long long minCost = cost[0][0];		int pathStartRow = 0;				// Find best row to start with		for(int i = 0; i < m; i++)		{			if(cost[i][0] < minCost)			{				minCost = cost[i][0];				pathStartRow = i;			}		}		vector<int> bestPath;		bestPath.push_back(pathStartRow);		int prevStartRow = pathStartRow;				for(int j = 1; j < n; j++)		{			int smallestRow = m;			// First 3 special cases to avoid extra processing and boundary handling (m <= 3 all can be reached)			if(m == 1)			{				smallestRow = 0;			}			else if(m == 2)			{				if(cost[0][j] <= cost[1][j])				{					smallestRow = 0;				}				else				{					smallestRow = 1;				}			}			else if(m == 3)			{				long long bestCost = min(cost[0][j], min(cost[1][j], cost[2][j]));				if(cost[0][j] == bestCost)				{					smallestRow = 0;				}				else if(cost[1][j] == bestCost)				{					smallestRow = 1;				}				else				{					smallestRow = 2;				}			}			else			{				// Find next best row based on current row (can wrap too)				long long bestCost = cost[prevStartRow][j];				for(int i = (prevStartRow + m - 1) % m; i != (prevStartRow + m + 2) % m; i = (i + 1) % m)				{					if(cost[i][j] < bestCost)					{						bestCost = cost[i][j];					}				}				for(int i = (prevStartRow + m - 1) % m; i != (prevStartRow + m + 2) % m; i = (i + 1) % m)				{					if(cost[i][j] == bestCost)					{						if(i < smallestRow)							smallestRow = i;					}				}			}			prevStartRow = smallestRow;			bestPath.push_back(prevStartRow);		}		for(int i = 0; i < bestPath.size(); i++)		{			cout<<bestPath[i]+1;			if(i != bestPath.size() - 1)				cout<<" ";		}		cout<<"\n";		cout<<minCost<<endl;	}		return 0;}