/* 	Solution to Programming Challenges Problem	http://www.programming-challenges.com		Author: Eric Kaggen	Problem: Hotter Colder (111404)		This solution favors readability over elegance. The	assumption is made that program input follows supplied	specifications. Handling of boundary cases outside of the	specifications is omitted. This is meant for fun rather than	practical use. Code style reflects the purpose of the code.*/#include <iostream>#include <vector>#include <algorithm>#include <string>#include <iomanip>#include <math.h>using namespace std;struct point{	double x, y;	point()	{		x=0;		y=0;	}	point(double a, double b)	{		x = a;		y = b;	}	bool operator == (const point other)	{		return other.x == x && other.y == y;	}	bool operator != (const point other)	{		return other.x != x || other.y != y;	}};struct intersection{	point pt;	point segmentBegin;	point segmentEnd;	bool pointIntersection;	int idx;	intersection(point isectPoint, point begin, point end)	{		pt = isectPoint;		segmentBegin = begin;		segmentEnd = end;		pointIntersection = false;		idx = 0;	}};struct pointSorter{	bool operator() (point a, point b)	{		if(a.y == b.y)		{			if(a.x == b.x)				return false;			return a.x < b.x;		}		else		{			return a.y < b.y;		}	}};struct intersectionSorter{	bool operator() (intersection a, intersection b)	{		if(a.pt.y == b.pt.y)		{			if(a.pt.x == b.pt.x)				return false;			return a.pt.x < b.pt.x;		}		else		{			return a.pt.y < b.pt.y;		}	}};struct idxSorter{	bool operator() (intersection a, intersection b)	{		if(a.idx == b.idx)		{			return false;		}		else		{			return a.idx < b.idx;		}	}};double polygonArea(vector<point>* polygon){	double sum = 0;	point a, b;	for(int i = 0; i < polygon->size(); i++)	{		a = polygon->at(i);		if(i == polygon->size() - 1)		{			b = polygon->front();		}		else		{			b = polygon->at(i+1);		}		sum += a.x * b.y - a.y * b.x;	}	return fabs(sum/2.0);}void removeDuplicates(vector<intersection>* isects){	for(int i = 0; i < isects->size(); i++)	{		isects->at(i).idx = i;	}	intersectionSorter intSorter;	sort(isects->begin(), isects->end(), intSorter);	vector<intersection>::iterator it = isects->begin() + 1;	intersection cur = isects->front();	while(it < isects->end())	{		if(it->pt.x == cur.pt.x && it->pt.y == cur.pt.y)		{			it = isects->erase(it);		}		else		{			cur = *it;			it++;		}	}	idxSorter idxSort;	sort(isects->begin(), isects->end(), idxSort);}double crossProduct(point p1, point p2, point p3){	return (p2.x - p1.x)*(p3.y - p1.y) - (p2.y - p1.y)*(p3.x - p1.x);}int segmentIntersection(point v1, point v2, point v3, point v4){	double numA = (double)(v4.x - v3.x) * (double)(v1.y - v3.y) - (double)(v4.y - v3.y) * (double)(v1.x - v3.x);	double numB = (double)(v2.x - v1.x) * (double)(v1.y - v3.y) - (double)(v2.y - v1.y) * (double)(v1.x - v3.x);	double den = (double)(v4.y - v3.y) * (double)(v2.x - v1.x) - (double)(v4.x - v3.x) * (double)(v2.y - v1.y);	if(den == 0.0)	{		return false;	}	double a = numA / den;	double b = numB / den;	if(b >= 0.0 && b <= 1.0)	{		if(b == 0.0 || b == 1.0)			return 2;		else			return 1;	}	return 0;	}void getPolygonIntersections(point v1, point v2, vector<point>* polygon, vector<intersection>* intersections){	bool flip = false;	point v3, v4;	for(int i = 0; i < polygon->size(); i++)	{		v3 = polygon->at(i);		if(i == polygon->size() - 1)		{			v4 = polygon->front();		}		else		{			v4 = polygon->at(i+1);		}		double numA = (v1.x*v2.y-v1.y*v2.x)*(v3.x-v4.x)-(v1.x-v2.x)*(v3.x*v4.y-v3.y*v4.x);		double numB = (v1.x*v2.y-v1.y*v2.x)*(v3.y-v4.y)-(v1.y-v2.y)*(v3.x*v4.y-v3.y*v4.x);		double den = (v1.x-v2.x)*(v3.y-v4.y)-(v1.y-v2.y)*(v3.x-v4.x);		if(den == 0.0)		{			continue;		}		point isect(numA/den, numB/den);		if(intersections->empty())		{			double cross1 = crossProduct(v3, v4, v1);			double cross2 = crossProduct(v3, v4, v2);			double dist1 = sqrt((isect.x - v1.x)*(isect.x - v1.x)+(isect.y- v1.y)*(isect.y - v1.y));			double dist2 = sqrt((isect.x - v2.x)*(isect.x - v2.x)+(isect.y- v2.y)*(isect.y - v2.y));			bool pointingTowards = dist1 > dist2;						if((pointingTowards && cross1 > 0 && cross2 > 0) || (!pointingTowards && cross1 < 0 && cross2 < 0) || (cross1 >= 0 && cross2 <= 0))			{				flip = true;			}			else			{				flip = false;			}		}		int isectType = segmentIntersection(v1, v2, v3, v4);		if(isectType != 0)		{			intersection interObj(isect, v3, v4);			if(isectType == 2)			{				interObj.pointIntersection = true;			}			intersections->push_back(interObj);		}	}	if(intersections->size() > 1)		removeDuplicates(intersections);	if(intersections->size() == 2 && flip)	{		intersection i1 = intersections->at(0);		intersection i2 = intersections->at(1);		intersections->pop_back();		intersections->pop_back();		intersections->push_back(i2);		intersections->push_back(i1);	}}vector<point>::iterator insertAfter(vector<point>::iterator pos, vector<point>* v, point pt){	if(pos == v->end())	{		v->push_back(pt);		return pos;	}	else	{		return v->insert(pos+1, pt)-1;	}}void reducePolygon(vector<point>* polygon, vector<intersection>* intersections, bool eliminateLeft){	intersection i1 = intersections->at(0);	intersection i2 = intersections->at(1);	vector<point>::iterator it;	for(it = polygon->begin(); it < polygon->end();)	{		double cross = crossProduct(i1.pt, i2.pt, *it);		int iteratorIncrement = 1;		if((eliminateLeft && cross > 0) || (!eliminateLeft && cross < 0))		{			if(i1.segmentBegin == *it && !i1.pointIntersection)			{				it = insertAfter(it, polygon, i1.pt);				iteratorIncrement++;			}			else if(i2.segmentBegin == *it && !i2.pointIntersection)			{				it = insertAfter(it, polygon, i2.pt);				iteratorIncrement++;			}			if(i1.segmentEnd == *it && !i1.pointIntersection)			{				if(it == polygon->begin())				{					it = polygon->erase(it);					polygon->push_back(i1.pt);										iteratorIncrement--;				}				else				{					*it = i1.pt;				}			}			else if(i2.segmentEnd == *it && !i1.pointIntersection)			{				if(it == polygon->begin())				{					it = polygon->erase(it);					polygon->push_back(i2.pt);										iteratorIncrement--;				}				else				{					*it = i2.pt;				}			}			else			{				it = polygon->erase(it);				iteratorIncrement--;			}		}		it+=iteratorIncrement;	}}int main(){	point curPos;	point lastPos;	double x,y;	string type;		vector<point> roomPoly;	roomPoly.push_back(point(0,0));	roomPoly.push_back(point(10,0));	roomPoly.push_back(point(10,10));	roomPoly.push_back(point(0,10));	vector<point> curPoly = roomPoly;	cout.setf(ios::fixed, ios::floatfield);	cout.setf(ios::showpoint);    while( cin>>curPos.x>>curPos.y>>type)    {		if(curPos != lastPos)		{			if(type == "Same")			{				if(curPos != lastPos)				{					curPoly.clear();				}			}			else			{				point mid((curPos.x + lastPos.x)/2, (curPos.y + lastPos.y)/2);				point rayStart(mid.x + mid.y - lastPos.y, mid.y - mid.x + lastPos.x);				point rayEnd(mid.x + mid.y - curPos.y, mid.y - mid.x + curPos.x);				bool eliminateLeft = false;				if(type == "Hotter")				{					eliminateLeft = true;				}				vector<intersection> intersect;				getPolygonIntersections(rayStart, rayEnd, &curPoly, &intersect);				if(intersect.size() != 2)				{					intersect.clear();					getPolygonIntersections(rayStart, rayEnd, &roomPoly, &intersect);				}				reducePolygon(&curPoly, &intersect, eliminateLeft);			}		}		cout<<setprecision(2)<<polygonArea(&curPoly)<<endl;		lastPos = curPos;	}    return 0;}