/* 	Solution to Programming Challenges Problem	http://www.programming-challenges.com		Author: Eric Kaggen	Problem: How Big Is It? (111308)		This solution favors readability over elegance. The	assumption is made that program input follows supplied	specifications. Handling of boundary cases outside of the	specifications is omitted. This is meant for fun rather than	practical use. Code style reflects the purpose of the code.*/#include <iostream>#include <string>#include <sstream>#include <vector>#include <list>#include <iomanip>#include <math.h>using namespace std;struct circle{	double r;	double x;	circle(double rad)	{		r = rad;	}	circle()	{		r = 0.0;	}};class Backtracker{	struct InputElement	{		circle value;		bool inSol;		InputElement(circle val)		{			this->value = val;			inSol = false;		}	};public:	vector<InputElement*> partialSolution;	vector<InputElement> input;	bool done;	Backtracker(vector<circle>* input)	{		this->bestWidth = -1;		this->done = false;		for(unsigned int i = 0; i < input->size(); i++)			this->input.push_back(InputElement(input->at(i)));	}		void backtrack(){			list<InputElement*> candidates;		list<InputElement*>::iterator it;		if(isSolution())		{			this->processSolution();			return;		}		constructCandidates(&candidates);		for(it = candidates.begin(); it != candidates.end(); it++)		{			partialSolution.push_back(*it);			(*it)->inSol = true;			// make move			backtrack();			partialSolution.pop_back();			(*it)->inSol = false;			if(done)				return;		}	}	double bestWidth;	bool isSolution()	{		return partialSolution.size() == input.size();	}		// Computes the width of the partial solution	double partialSolutionWidth()	{		// next x, x2 is x1 + 2 sqrt(r1*r2)		double rightEdge = partialSolution.front()->value.r*2;		partialSolution.front()->value.x = partialSolution.front()->value.r;		for(unsigned int i = 1; i < partialSolution.size(); i++)		{			circle* c1 = &partialSolution.at(i-1)->value;			circle* c2 = &partialSolution.at(i)->value;			double delta = 2 * sqrt(c1->r*c2->r);			double newX = c1->x + delta;			for(unsigned int j = 0; j < i; j++)			{				circle* check = &partialSolution.at(j)->value;				double deltaCheck = 2 * sqrt(c2->r*check->r);				newX = max(c2->r, max(newX, deltaCheck + check->x));			}			c2->x = newX;			if(c2->x + c2->r > rightEdge)				rightEdge = c2->x + c2->r;		}		return rightEdge;	}		// Test if the new solution is better than existing ones	void processSolution()	{		double width = partialSolutionWidth();		if(bestWidth == -1 || width < bestWidth)		{			bestWidth = width;		}	}	// Candidates are all circles not already in input	void constructCandidates(list<InputElement*>* candidates)	{		for(unsigned int i = 0; i < input.size(); i++)		{			InputElement* element=  &input.at(i);			if(!element->inSol)				candidates->push_back(element);		}	}};int main(){	int cases, n;	string line;	cin>>cases;	cout.setf(ios::fixed, ios::floatfield);	cout.setf(ios::showpoint);	while(cases-- > 0)	{		vector<circle> circles;		cin>>n;		for(int i = 0; i < n; i++)		{			circle circle;			cin>>circle.r;			circles.push_back(circle);		}				Backtracker backtracker(&circles);		backtracker.backtrack();		cout<<setprecision(3)<<backtracker.bestWidth<<endl;	}	return 0;}